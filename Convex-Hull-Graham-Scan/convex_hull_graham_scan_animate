
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from matplotlib.animation import PillowWriter

fig, ax = plt.subplots(figsize=(6,6))
ax.set_xlim(0, 10)
ax.set_ylim(0, 10)
plt.title("Click points (Enter to finish)") 
points_clicked = plt.ginput(n=-1, timeout=0)  # unlimited clicks until Enter/middle click

line1, line2 = ax.plot([], [], 'r--', [], [], 'b-')

# Test if three points in R2 form a right-hand turn in the order they are listed
def is_right_turn(points):
    # The input must be a list of three 2d points
    if len(points) != 3:
        print("List must contain exactly three points")
    elif any([len(pt) != 2 for pt in points]):
        print("All points must be 2d")
    else:
        # test if p3 lies to the right of the line
        # p1p2 by using the cross product,
        # i.e. imagine all points as living in
        # a 2d subspace of R3.
        
        points = np.array(points)
        
        p1_to_p2 = points[1] - points[0]
        p1_to_p3 = points[2] - points[0]

        cross_prod_comp = (p1_to_p3[0]*p1_to_p2[1] - 
                           p1_to_p3[1]*p1_to_p2[0])

        if cross_prod_comp > 0:
            return True
        else:
            return False

# Compute the convex hull of a list of points in R2, output the convex hull
# as a the list of points forming the convex hull read clockwise. Also ouput
# the intermediate steps of the algorithm for the purpose of the animation.
def convex_hull_2d(points):
    if len(points) < 3:
        print("There must be at least three points")
    else:
        # Sort the points lexographically
        points = sorted(points)
        l_upper = [points[0], points[1]]
        steps = []
        for i in range(2, len(points)):
            l_upper.append(points[i])
            while len(l_upper)>2 and (not is_right_turn(l_upper[-3:])):
                steps.append(l_upper.copy())
                l_upper.pop(-2)
            steps.append(l_upper.copy())

        l_lower = [points[-1], points[-2]]
        upper_hull = steps[-1]
        for i in range(len(points)-2 - 1, 0 - 1, -1):
            l_lower.append(points[i])
            while len(l_lower)>2 and (not is_right_turn(l_lower[-3:])):
                steps.append(upper_hull[:-1] + l_lower.copy())
                l_lower.pop(-2)
            steps.append(upper_hull[:-1] + l_lower.copy())
        l_lower.pop(0)
        l_lower.pop(-1)
        l_upper.extend(l_lower)
        return l_upper, steps

x1, y1 = np.array(points_clicked).T
convex_hull_points, steps = convex_hull_2d(points_clicked)
# Keep a list of all the lines in the convex hull, this allows to plot some lines
# as solid blue and some as red dashed in the animation, depending if they are in
# final convex hull or just represent intermediate steps.
convex_hull_lines = []
for i in range(len(convex_hull_points)-1):
    convex_hull_lines.append([convex_hull_points[i], convex_hull_points[i+1]])
convex_hull_lines.append([convex_hull_points[-1], convex_hull_points[0]])

# The initial state of the animation.
def init():
    line1.set_data([], [])
    line2.set_data([], [])
    return line1, line2

# The function which updates each frame of the animation.
def update(frame):
    ax.plot(x1,y1,'r+') 
    hull_temp = steps[frame]
    hull_solid_lines = [hull_temp[0]]
    for i in range(len(hull_temp)-1):
        if not [hull_temp[i], hull_temp[i+1]] in convex_hull_lines:
            break
        hull_solid_lines.append(hull_temp[i+1])
        
    if hull_solid_lines == [hull_temp[0]]:
        hull_solid_lines = []
    
    if hull_solid_lines == []:
        hull_dashed_lines = np.array(hull_temp)
        line1.set_data(hull_dashed_lines[:,0], hull_dashed_lines[:,1])
        line2.set_data([], [])
    else:
        hull_dashed_lines = np.array([hull_solid_lines[-1]]+
                                     hull_temp[len(hull_solid_lines):])
        hull_solid_lines = np.array(hull_solid_lines)
        if len(hull_dashed_lines)==1:
            line1.set_data([],[])
            line2.set_data(hull_solid_lines[:,0], hull_solid_lines[:,1])
        else:
            line2.set_data(hull_solid_lines[:,0], hull_solid_lines[:,1])
            line1.set_data(hull_dashed_lines[:,0], hull_dashed_lines[:,1])
    return line1, line2

animation = FuncAnimation(fig=fig, 
                          func=update, 
                          init_func=init,
                          frames=len(steps),
                          interval=300, 
                          repeat=False)

# To save the animation using Pillow as a gif
# writer = PillowWriter(fps=15,
#                       metadata=dict(artist='Me'),
#                       bitrate=1800)
# ani.save('scatter.gif', writer=writer)

plt.show()
